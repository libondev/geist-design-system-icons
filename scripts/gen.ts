import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'

import glob from 'fast-glob'

import cachedIcons from './_cached.json' assert { type: 'json' }
import metadata from './_metadata.json' assert { type: 'json' }

type SVGMap = Record<string, string>

const writeTypes = process.argv.slice(2)

const QUOTE_REGEX = /^"|"$/g
const INTEGER_REGEX = /^\d+$/
const BREAK_PROPS_REGEX = /\s+(?=\w+(?:-\w+)*=)/
const SVG_REGEX = /<svg\s?([^>]*)>([\s\S]*?)<\/svg>/

function isDirectoryDirty(_path: string) {
  const stats = fs.statSync(fileURLToPath(new URL(_path, import.meta.url)))

  return stats.mtime.toLocaleString()
}

function updateMetadata(modifiedAt: string) {
  metadata.lastModified = modifiedAt

  fs.writeFileSync('./scripts/_metadata.json', `${JSON.stringify(metadata, null, 2)}\n`)
}

function updateCachedIcons() {
  const RENAME_REGEX = /svg\/(.*?)\.svg/
  const CAMEL_CASE_REGEX = /-(\w)/g

  const newContent: SVGMap = Object.fromEntries(
    glob.sync('svg/*.svg', { cwd: process.cwd() }).map((svg) => {
      const fileName = svg.replace(RENAME_REGEX, '$1')
      const camelCaseName = fileName.replace(CAMEL_CASE_REGEX, (_, $) => $.toUpperCase())
      const name = `${camelCaseName.slice(0, 1).toUpperCase() + camelCaseName.slice(1)}Icon`

      const content = fs.readFileSync(svg, 'utf-8')

      return [name, content]
    }),
  )

  fs.writeFileSync('./scripts/_cached.json', `${JSON.stringify(newContent, null, 2)}\n`)

  return newContent
}

const transformers = {
  vue(fileHead: string, svgMap: SVGMap) {
    let fileContent = `${fileHead}import { defineComponent, h } from 'vue'\n\n`

    for (const [name, content] of Object.entries(svgMap)) {
      const [, attributes, children] = content.match(SVG_REGEX) || []
      const props = attributes?.split(BREAK_PROPS_REGEX)
        .map((attr) => {
          const [key, ...values] = attr.split('=')
          const value = values.join('=').replace(QUOTE_REGEX, '')

          const isNumeric = INTEGER_REGEX.test(value)

          return `"${key}":${isNumeric ? value : `"${value}"`}`
        })

      fileContent += `export const ${name} = defineComponent(() => h("svg", { innerHTML:'${children}',${props} }), { name:'${name}' })\n`
    }

    return fileContent
  },
  react(fileHead: string, svgMap: SVGMap) {
    let fileContent = `${fileHead}import { createElement, memo, type MemoExoticComponent, type SVGProps, type ReactSVGElement } from 'react'\n`
    fileContent += `type MF = MemoExoticComponent<(props: SVGProps<any>) => ReactSVGElement>\n\n`

    for (const [name, content] of Object.entries(svgMap)) {
      const [, attributes, children] = content.match(SVG_REGEX) || []
      const props = attributes?.split(BREAK_PROPS_REGEX)
        .map((attr) => {
          const [key, ...values] = attr.split('=')
          const value = values.join('=').replace(QUOTE_REGEX, '')
          const camelCase = key.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())

          if (camelCase === 'style') {
            const css = value.split(';').reduce((acc, cur) => {
              const [key, value] = cur.split(':')

              return `${acc}${key}:"${value}",`
            }, '').slice(0, -1)

            return `style:{${css}}`
          }

          // 处理数字类型的值
          const isNumeric = INTEGER_REGEX.test(value)
          // 使用冒号而不是等号
          return `${camelCase}:${isNumeric ? value : `"${value}"`}`
        })

      const processedChildren = children
        .replace(/([a-z]+-[a-z]+)=/g, (match) => {
          return match.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())
        })
        .replace(/\s+/g, ' ')
        .trim()

      fileContent += `export const ${name}: MF = memo(props => createElement("svg", { ${props},...props,dangerouslySetInnerHTML:{__html:'${processedChildren}'} }))`
      fileContent += `\n${name}.displayName = '${name}'\n\n`
    }

    return fileContent
  },
  vanilla(fileHead: string, svgMap: SVGMap) {
    let fileContent = fileHead

    for (const [name, content] of Object.entries(svgMap)) {
      fileContent += `export const ${name} = '${content}'\n`
    }

    return fileContent
  },
}

type WriteType = keyof typeof transformers

async function run(writeType: WriteType, svgMap: SVGMap) {
  const fileHead = '// This file is generated by script/gen.ts, please do not modify it manually.\n'

  const fileContent = transformers[writeType as keyof typeof transformers](fileHead, svgMap)

  const modulePaths = path.resolve(process.cwd(), 'src', `${writeType}.ts`)

  fs.writeFileSync(modulePaths, fileContent)
}

; (async () => {
  const lastModified = isDirectoryDirty('../svg')

  let svgMap: SVGMap = cachedIcons

  if (lastModified !== metadata.lastModified) {
    updateMetadata(lastModified)
    svgMap = updateCachedIcons()
  }

  writeTypes.filter(type => type in transformers).forEach((type) => {
    run(type as WriteType, svgMap)
  })
})()
